객체와 자료구조
--

객체지향에 대한 지식도 어느정도 녹아있어 좋아하는 챕터다.  

## 자료 추상화
**객체는 내부 구현을 숨겨야 한다. 아주 꽁꽁.**    
캡슐화는 의도하지 않은 값의 변경을 최소화 하고, 변경에 대한 사이드 이펙트를 줄여 확장성을 갖게한다.  

일반적으로 Getter 와 Setter 가 가짜 캡슐화를 시키는 악의 근원이다.  
> 보통 웹 어플리케이션에서는 Serialize 를 위하여 일반적으로 Getter 는 제공하지만, 비즈니스 로직에서는 최소한으로 사용하는 편이 좋다.    
> Getter 와 Setter 를 줄이는 가장 쉬운 방법은 행위를 하는데 있어 가장 많은 정보를 지닌 객체에 그 행위의 책임을 맡기는 것이다.  
> 이를 정보 전문가 패턴이라고 한다.  Clean Code 요약이므로 자세한 설명은 생략한다

(1)
``` java
 public void main() {
    if (type == Birds) {
        Bird bird = new Bird();
        bird.fly();
    } else if (type == Persons) {
        Person person = new Person
        person.run();
    }
 }
```
(2)
``` java
public void main() {
    MovingThings movingThings = MovingThingsFactory.create(type);
    movingThings.move();
}
public interface MovingThings {
   void move();
}

public class Bird() implements MovingThings {
    @Override
    public void move() {
        fly()   
    }
}

public class Person() implements MovingThings {
    @Override
    public void move() {
        run()
    }
}
```

1 번과 2 번을 비교해보자, 두 소스 모두 타입을 받아서, 해당하는 객체를 움직이는 메서드다.  
만약 여기서 새가 움직이는 방법을 walk() 로 변경하려고 할때,  
(1) 번의 경우는 Bird 에 walk() 메서드를 추가하고, main 메서드 또한 바꿔야 한다.  
(2) 번의 경우는 Bird 클래스만 수정하면 된다. 이러한 변경점의 갯수는 Bird **클래스를 사용하는 클라이언트 클래스가 늘어날 수록 더 증가하게 될 것이다.**  

> Person 과 Bird 를 한번 더 추상화 하는게 적절한 예시 같지만 너무 길어져서 여기까지..  
책에는 추상화의 중요성이 제대로 드러나지 않는 것 같아 설명을 많이 덧붙였다.


## 자료구조와 객체
객체와 자료구조는 엄연히 다르다. 많은 OOP 관련 책들에서 이를 명확히 구분하라고 한다.  

**자료구조** : 자신의 자료를 외부에 드러내며, 오로지 자료의 전달을 목적으로 하는것. 
**객체** : 자신의 자료를 외부에 드러내지 않고, 자신의 자료로 어떤 일관적인 책임을 지는 행위를 하는 것  

이를 명확하게 구분짓지 않은 클래스들을 잡종구조 라고한다.  

자료구조를 100% 활용하는 코드를 일반적으로 **절차지향** 이라고 한다.   
반대로 객체를 활용하는 코드를 **객체지향** 이라고 한다.  

두 패러다임은 각자 장단점이 있다.  
- 절차지향 코드는 기존 자료 구조를 변경시키지 않고 **새 함수를 추가하기 쉽다.**  
그저 자료구조의 클라이언트가 되는 main 함수에 새 메서드를 만들면 된다.  
하지만 새 자료구조를 추가하기가 어렵다. 해당하는 모든 클라이언트에 클래스를 판단하는 조건문을 한줄 추가해야 할 것이다.  

- 반대로 객체지향 코드는 **새 객체를 추가하기 쉽다.** 인터페이스를 구현하는 새 객체를 생성하기만 하면된다.   
하지만 또 다른 행위를 하는 새 메서드를 추가하기는 어렵다. 인터페이스를 구현하는 모든 객체에 해당 메서드를 구현해야하니까.  

각자 장단점이 있기에 어떤 패러다임을 선택하느냐는 상황에 따라 다르지만,  
잡종 구조는 이야기가 다르다. 잡종구조는 어느것도 쉽게 만들어 주지 않는다.

> 예시로 들만한 잡종 구조로 프로젝트 전역에 깔려있는 xxVO 클래스들이다.
> DTO 로 사용되지만 이름은 VO 이며 Getter Setter 도 제공하지만 많은 행위도 하고 있는 슬픈 현실이다.
> 일반적으로 DTO 만이 객체지향 코드에서 존재해야하는 자료 구조라고 생각한다.

## 디미터 법칙
**디미터 법칙이란?**
클래스 C 의 메서드 f 는 
- 클래스 C
- f 가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수
의 메서드만 호출해야 한다. 라는 법칙이다.
  
즉 직접적인 연관관계가 있는 객체에만 메시지를 전달하라는 이야기이다.  

``` java
SettingInsurance settingInsurance = payroll.getSettingMapper().getSettingInsurances().findBy(TaxType.BUSINESS)
```
위와 같은 코드를 '기차 충돌' 이라고 한다. 책에서는 '조잡하다' 라고 표현한다..  
이를 조금 개선해보면

``` java
SettingMapper settingMapper = payroll.getSettingMapper();
SettingInsurances settingInsurances = settingMapper.getSettingInsurances();
SettingInsurance settingInsurance = settingInsurances.findBy(TaxType.BUSINESS);
```

**위 코드는 기차충돌인가?**   

일단 내 생각엔 아니다.  
SettinMapper 와 SettingInsurances 는 자신 내부에 있는 객체를 전달만 하는 자료구조다.  
(물론 저런식으로 꺼내쓰는게 보기 싫어서 update() 같은 행위를 하위 필드들에게 전달하는 메서드 정도는 추가했다.)  
디미터 법칙은 '객체' 에만 적용되는 법칙이다. 책에서는 자료구조라면 getter 대신 public 필드를 사용하면 혼란을 줄인다고 한다.  
하지만 이 부분에 있어서는 너무 기존 프로젝트들과 달라지기 때문에 흥선대원군 스탠스를 취하고 싶다.  

## 구조체 감추기 (캡슐화)
위에서 설명한 캡슐화가 또 나온다.  
만약 위의 자료구조 들이 객체라면 저런식으로 내부 구현을 get 시켜 처리하는 코드를 짜는것이 아닌,  
settingMapper.doSomething(SomeParameters) 으로 메시지를 전달하는 구조의 코드가 되어야 한다.  
즉 행위를 수행하기 위한 정보를 가지고 있는 객체가 수행하게끔 하는 정보 전문가 패턴이 또 등장하는 것이다.  

## 자료 전달 객체
자료 구조체의 전형적인 형테가 DTO 라고 책은 설명한다.  
책에서는 DTO 역시 자료구조 이므로 public 변수만 포함해야하고 private 인스턴스에 getter, setter 를 추가하는것은 사이비 캡슐화라고 한다.  
이 부분에 대해 이야기를 해봅시다.

## 활성 레코드
save나 find 같은 탐색이나 단순 변경 함수를 포함한 자료구조를 뜻한다.  
활성레코드 역시 '자료구조' 이므로 비즈니스 로직은 포함해서는 안된다. 잡종구조를 낳지말자.
> 위의 Insurances, SettingMapper 와 같은 클래스를 뜻한다고 생각한다. 

## 느낀점 
너무 좋아하는 이야기들이 많아서 주관적인 설명이 많이 덧붙었다.  
절차지향과 객체지향에는 각자 장단점이 있다고 하지만, 기계에 적용되어 일관적이게 돌아가는 프로그램이 아닌 이상  
비즈니스 요구사항은 끊임없이 변덕적이게 변하기 때문에, 우리의 경우엔 객체지향이 대부분 일반적으로 맞을 것이다.    
다 같이 꾸준히 역량을 키워서 더 확장성 있는 서비스를 개발했으면 좋겠다.  
말도 안되는 요구사항이 들어올때 그건 어려운데요.. 뭘 저런걸 요구하냐 보다는  
어 좀 귀찮네? 정도 수준에서 기능 추가를 할 수 있는 그런 서비스를 만듭시다. 짞짝  



