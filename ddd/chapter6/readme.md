## AGGREGATE

일반적인 객체 모델의 관계망은 잠재적인 변경의 효과의 범위를 명확히 한정해주지 않는다.  
그러므로 모든 객체의 사용자가 논리적으로 명확히 범위를 인지하고 있지 않는한 변경의 일관성이 보장되지 않는다.  
  
-> 모델들의 참조에 대한 캡슐화를 추상화할 필요가 있다!  
  
**AGGREGATE** 란 **데이터 변경의 단위로 다루는 연관객체의 묶음**이다.  

- AGGREGATE 를 구성하는 대표적인 규칙은 다음과 같다.  
1. 각 AGGREGATE 에 는 하나의 ROOT 와 BOUNDARY(경계)가 존재한다.  
2. BOUNDARY 바깥의 개체는 AGGREGATE ROOT 에만 접근이 가능하다.  
3. BOUNDARY 내부에선 얼마든지 상호참조 가능하며 루트 이외의 엔티티는 외부에서 볼 수 없고 지역 식별성을 가진다.


- 실 서비스에서의 AGGREGATE 규칙을 풀어보면 다음과 같은 규칙들이 생긴다.  
1. 데이터베이스에 직접적인 질의로는 루트만이 직접 획득할수있다.
2. 군집 안의 객체는 다른 군집 루트만 참조된다.
3. 삭제연산은 군집 안의 모든 요소를 한번에 제거해야하다.
4. 루트가 아닌 ENTITY 를 루트를 통하여 넘겨줄 순 있지만, 저장해서는 안된다. VALUE OBJECT 는 복제본을 넘겨주어 불변식이 깨지지 않도록 한다.     
5. 경계안의 어떤 객체를 변경해도 전체 군집의 불변식은 유지되야한다.

---

## FACTORY

전체 AGGREGATE 를 생성하는 일이 복잡해지거나 내부 구조가 많이 드러나는 경우 FACTORY 를 이용한다.  

객체의 장점은 각각에 책임을 정교하게 분배하는데서 나온다.    
실무에서 충분히 복잡한 책임을 안고있는 객체들에게 객체를 생성하는 책임까지 맡기는것은 시스템의 복잡성과 예측불가능한 예외를 야기시키는 경우가 있고   
객체의 생성 자체가 객체의 내부구조를 많이 알고 있어야 한다는 점에서 캡슐화에 위배 되며 객체간의 결합도를 높인다.  

이러한 문제를 해결하기위해 FACTORY 를 도입해야한다.

**FACTORY** 는 **객체 생성에 대한 지식을 캡슐화하고 객체 생성에 대한 책임을 위임받은 프로그램 요소**이다.  
클라이언트가 인스턴스화할 객체의 구상클래스를 참조할 필요가 없는 인터페이스를 FACTORY를 통하여 제공하자  


### FACTORY 를 설계하는 요건
1. 각 생성방법은 원자적이어야하며, AGGREGATE 의 **불변식을 지켜야한다**. ENTITY의 경우는 AGGRAGATE 전체의 불변식을 말하며,  
   VALUE OBJECT 는 모든 속성이 완전함을 이야기한다. 올바르게 생성하지 못하는 객체에 대해서는 예외를 발생시켜라  
   
2. FACTORY는 생성된 클래스보다는 **생성하고자 하는 타입으로 추상화** 되어야한다.  


### FACTORY 의 위치선정
크게 3가지로 나눠질 수 있다.
1. AGGREGATE ROOT 에 BOUNDARY 내부 객체에 대한 FACTORY METHOD 를 생성
2. 객체를 소유하진 않지만 객체를 만들어내는 것과 밀접한 책임이 있는 객체에 FACTORY METHOD
3. 독립적인 FACTORY 분리 

-> FACTORY 는 생성하는 객체와 매우 강하게 결합되어있으므로 FACTORY는 생성물과 **가장 밀접한 객체**에 존재해야한다.  
구상 구현체나 생성과정의 복잡성을 캡슐화해야한다면, FACTORY 객체나 SERVICE 를 생성해야한다.  

### 공개 생성자를 제공하는 경우
생성자만으로 충분한경우엔 FACTORY 보다는 공개 생성자로 제공하는 편이 오히려 복잡성을 낮춘다.

1. 클래스가 타입인 경우, 즉 다형적으로 사용되는 타입이 아닌경우.
2. 클라이언트가 STRATEGY를 선택하는 방법으로서, 구현체에 관심이 있는 경우
3. 클라이언트가 객체 속성을 모두 이용할 수 있어서 생성의 책임이 클라이언트에게 추가적인 정보를 제공하지 않는 경우
4. 생성자가 복잡하지 않은 경우

공개 생성자가 FACTORY와 동일한 규칙을 준수해야하는 경우, 해당 규칙은 생성 객체에 대한 모든 불변식을 만족하는 원자적인 연산이어야한다.  
다른 객체의 생성자에서 생성자를 호출하지 않는다. 생성자는 극도로 단순하게 유지하자.  

### FACTORY의 인터페이스 설계  
독립형 FACTORY 나 FACTORY METHOD 모두 다음의 규칙을 만족해야한다.  

1. 각 연산은 원자적이어야한다.  
   불변식을 위배하는 객체를 생성하는 경우 예외나 반환 값에 대한 표준을 도입하라.  
2. FACTORY 는 전달받은 객체와 결합한다.  
  인자가 단순히 생성물에 들어가는 것이 가장 의존성이 적당한 상태이며, 인자를 끄집어내어 생성 과정에 이용한다면 결합이 더 강해질것이다.  
  즉 **생성에 가장 밀접한 객체** 그리고 가장 **하위 수준의 객체** 그리고 구체클래스가 아닌 **추상적인 타입**을 매개변수로 삼아 결합도를 낮추어라


### 불변식의 위치
FACTORY 는 불변식의 위치가 될 수 있다.  
객체 스스로 뿐만 아니라 생성에 대한 정보를 모두 지니고 있는 FACTORTY 역시 불변식이 있기 적절한 위치가 될 수 있다.  

### 재구성 FACTORY
객체를 영속화 할 때, 객체의 특성이나 내용을 그대로 유지하는 경우는 거의 없다.  
즉 비즈니스에서 사용한 객체를 영속화할때 재구성된 객체를 생성하는 FACTORY를 말한다.  

- 재구성 FACTORY는 FACTORY 의 대부분의 규칙을 만족해야하지만 2가지 차이점이 있다.
1. 재구성 FACTORY는 새 ID를 할당하지 않는다.
2. 불변식 위반을 단순히 객체를 생성하지 않는 것이 아닌 더 탄력적인 방법으로 처리해야한다. 



