
OBJECT - Chater 6 메시지와 인터페이스
--
###클라이언트-서버모델
객체를 각각이 클라이언트와 서버라고 생각하자.   
서로 메시지를 주고 해당 메시지에 대한 응답만을 받는 협력이라는 단방향 상호작용을 하는 관계이다.  

###디미터 법칙
오직 인접한 이웃하고만 말하라.  
극단적으로 객체지향생활체조의 “오직 하나의 도트만 사용하라” 로도 표현한다.  
- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체  
  
와 같은 직접적으로 관련있는 객체에만 메시지를 보내라



###묻지말고 시켜라
객체의 상태를 묻지말고, 그 상태를 지닌 객체에게 시켜라.   

자연스럽게 정보 전문가에게 책임을 할당하고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.


###의도를 드러내는 인터페이스

어떻게’가 아니라 ‘무엇’을 하는지를 드러내는 것  
이름을 추상화 하다보면 설계도 추상화의 레벨이 높아지게 된다.  
캡슐화는 인터페이스의 이름에도 깨질수 있다. 내부 구현을 인터페이스명에 드러나지 않도록 하자.  

### 결합도와 응집도의 충돌

항상 원칙을 준수하려고 하진마라. 원칙을 준수하지 않을 때가 더 나을때도 있다.  
책임을 고려하지 않고 무작정 시키기만 한다면 여러 책임을 떠 안고 있는 객체들이 여기저기 생겨날 것이다.  
때론 시키기보다 묻는것이 나을때가있다
>설계는 Trade Off의 산물임을 잊지말자.


###명령-쿼리 분리 원칙
명령(Command) = 프로시저 -> 부수효과를 발생시키되, 값을 반환하지 않는다.  
쿼리(Query) = 함수 -> 부수효과를 발생시키지 않고, 값을 반환한다.

**명령 쿼리 분리 원칙**
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

명령과 쿼라를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다  
코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것  


> **참조 투명성이란?**  
> input 이 같으면 output이 같다는 함수형 프로그래밍의 기본 원칙.   

객체 지향패러다임에서는 '상태변경' 이라는 부수효과에 기반하기 때문에 참조 투명성은 예외에 가깝고 이는 객체지향의 견고함에 오점이 된다.  
하지만 명령 - 쿼리 원칙을 통하여 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 하는것이다.



###책임에 초점을 맞춰라
위의 모든 원칙들을 만족 시키는 쉬운 방법이 있다.   
모든 객체지향 관련 서적에서 이야기하는 메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것!