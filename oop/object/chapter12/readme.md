OBJECT - Chater 12 다형성
--

### 다형성의 종류

유니버셜 다형성
- 매개변수 다형성 
- 포함 다형성

임시 다형성
- 오버로딩 다형성
- 강제 다형성

1. 오버로딩 다형성
``` java
add(Long a)
add(Double a)
add(Integer a)
```
오버로딩을 사용하면 기억해야하는 이름을 극적으로 줄일수있다.

2. 강제다형성  
언어가 지원하는 자동적인 타입변환 혹은 사용자가 구현한 타입변환을 이용하여 동일한 연산을 다양한 타입에 사용할 수 있는 방식 (ex String의 + 와 숫자의 +)

3. 매개변수 다형성  
   ex) 제네릭 호출 시점의 동적인 타입 바인딩

4. 포함 다형성   
   ex) 동일한 메시지지만 수신한 객체의 타입에 따라 수행되는 행동이 달라지는 능력

**상속의 진정한 목적은 -> 코드 재사용이 아닌 다형성을 위한 서브타입 구축**  
타입 계층에 대한 고민 없이 코드를 재사용하기 위해 상 속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다!

### 관점에 따른 상속
- 데이터 관점의 상속  
데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.

- 행동 관점의 상속  
행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미
  
부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.   
런타임에서 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 해당 메서드를 부모 클래스 안에서 탐색하기 때문이다.    
객체의 경우 서로 다른 상태를 저장할 수 있도록 각 인스턴스 별로 독릭접인 메모리를 지닌다.   
하지만 메서드는? 클래스당 하나만 메모리에 로드된다.    
상속 객체의 퍼블릭 인터페이스는 런타임에서 시스템이 상속 그래프를 거슬러 올라가면서 탐색된다.  


### 업캐스팅과 동적 바인딩

부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 *업캐스팅*이라고 부른다.    

선언된 클래스가 아닌 런타임에서 메시지를 수신한 객체가 행위를 수행한다 이를 *동적 바인딩*이 라고부른다.  

이 두가지 기능이 코드를 변경하지 않고 기능을 추가할 수 있는 OCP 에 위배되지 않는 설계를 가능케 돕는다.  
동일한 시그니처를 가지는 자식 클래스의 메서드는 부모 클래스의 메서드를 감추지만 이틈만 같고   
시그니처가 완전히 동일하지 않은 메서드들은 상속 계층에 걸쳐 사이좋게 공존할 수도 있다. 이것을 *메서드 오버로딩*이라고 한다.  

### self 참조
self 전송이 깊은 상속 계층과 계층 중간중간에 숨겨져 있는 메서드 오버라이딩과 만나면 매우 이해하기 어려운코드가 만들어진다.  

self 참조의 가장 큰 특징은 동적이라는 점이다 self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행시점에 결정함.  
self 참조는 메시지를 수신한 객체이다. 동적으로 결정된 self 참조는 상속 그래프를 따라 행위를 수행할때 까지 전달된다.    
  
*self 와 super*

super 에 의해 호출되는 메서드는 부모 클래스의 메서드가 아니라 더 상위에 위치한 조상 클래스의 메서드일 수도 있다.
지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작해서 수행가능한 지점을 만날때 까지 탐색한다.

self 탐색은 메시지를 수신하는 객체의 클래스에 따라 메서드를 탐색할 시작 위치를 동적으로 결정하는데 비해  
super 탐색은 항상 메시지를 전송하는 클래스의 부모 클래스에서부터 시작된다.  